function A=euler(varargin)

  nargs=length(varargin);
  if nargs==3
    PHI=varargin{1};
    theta=varargin{2};
    phi=varargin{3};
  elseif nargs==1
    PHI=varargin{1}(1);
    theta=varargin{1}(2);
    phi=varargin{1}(3);
  else
    error('Must be called with a three scalar arguments or one vector argument of length 3.');
  end

  if strcmp(typeinfo(PHI), 'swig_ref') || strcmp(typeinfo(theta), 'swig_ref') || strcmp(typeinfo(phi), 'swig_ref')
    global swigGlobalModuleVar_fmatvec_symbolic_swig_octave;
    sym=swigGlobalModuleVar_fmatvec_symbolic_swig_octave;
    A=vertcat(horzcat(sym.cos(phi)*sym.cos(PHI)-sym.sin(phi)*sym.cos(theta)*sym.sin(PHI),...
                      -sym.cos(phi)*sym.cos(theta)*sym.sin(PHI)-sym.sin(phi)*sym.cos(PHI),...
                      sym.sin(theta)*sym.sin(PHI)),
              horzcat(sym.cos(phi)*sym.sin(PHI)+sym.sin(phi)*sym.cos(theta)*sym.cos(PHI),...
                      sym.cos(phi)*sym.cos(theta)*sym.cos(PHI)-sym.sin(phi)*sym.sin(PHI),...
                      -sym.sin(theta)*sym.cos(PHI)),
              horzcat(sym.sin(phi)*sym.sin(theta),...
                      sym.cos(phi)*sym.sin(theta),...
                      sym.cos(theta)));
  else
    A=[cos(phi)*cos(PHI)-sin(phi)*cos(theta)*sin(PHI),...
       -cos(phi)*cos(theta)*sin(PHI)-sin(phi)*cos(PHI),...
       sin(theta)*sin(PHI);
       cos(phi)*sin(PHI)+sin(phi)*cos(theta)*cos(PHI),...
       cos(phi)*cos(theta)*cos(PHI)-sin(phi)*sin(PHI),...
       -sin(theta)*cos(PHI);
       sin(phi)*sin(theta),...
       cos(phi)*sin(theta),...
       cos(theta)];
  end
